// Generated by CoffeeScript 1.6.2
var Settings, add, api, argv, async, build, build_client_path, build_dir, build_lib_path, build_path, build_public_path, cd, chokidar, clean_up, client_dir, coffee, coffee_clean, coffee_compile, coffee_ext, coffee_paths, coffee_watch, collectExt, command, commands, compare_file, cp, cpdir, create, cs, cubesat_name, cubesat_package_path, cubesat_path, cwd, daemon, directives, dot_cubesat, dot_cubesat_path, dot_sat, dot_sat_path, dotenv, eco, env, error, exec, f, findRoot, fs, func, getVersion, github_file, github_url, gitpass, help, hold_watch, home, https, incVersion, index_basename, index_coffee, index_coffee_path, init, init_settings, isType, jade, lib_dir, lib_files, loadSettings, log, meteor, meteor_command, meteor_install, meteor_packages, meteor_packages_removed, meteor_publish, meteor_publish_command, meteor_update, mkdir, mobile_packages, mongo_port, mongo_url, my_packages, nconf, no_seperator, nocacheRequire, node_modules, npm_install, npm_publish, npm_update, package_js, package_json, package_paths, path, ps, public_dir, public_files, publish, rePublish, readExports, readWrite, rmdir, run, settings, settings_json, settings_path, site_path, spawn, spawn_command, start_meteor, start_up, stop_meteor, style_path, stylus, task, tasks, test, test_client_path, test_lib_path, test_packages_path, test_path, test_public_path, toObject, toString, toTidy, to_be_removed_publish, to_be_removed_update_mobile, updated, version, write_build, x, _add_packages, _meteor_run_ios, _prepare_mobile, _ref, _remove_packages,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

fs = require('fs');

path = require('path');

ps = require('ps-node');

cs = require('coffee-script');

eco = require('eco');

chokidar = require('chokidar');

https = require('https');

jade = require('jade');

stylus = require('stylus');

async = require('async');

dotenv = require('dotenv');

nconf = require('nconf');

api = require('absurd')();

_ref = require('child_process'), spawn = _ref.spawn, exec = _ref.exec;

x = require('cubesat').x;

cs.register();

command = process.argv[2];

argv = require('minimist')(process.argv.slice(3));

add = path.join;

home = process.env.HOME;

cwd = process.cwd();

mongo_port = 27017;

mongo_url = "mongodb://localhost:" + mongo_port + "/meteor";

build_dir = 'build';

index_basename = 'index';

coffee_ext = '.coffee';

index_coffee = index_basename + coffee_ext;

package_js = 'package.js';

package_json = 'package.json';

findRoot = function(d) {
  var dir_list;

  dir_list = process.cwd().split('/').concat([true]);
  while (dir_list.pop()) {
    if (fs.existsSync(add(dir_list.join('/'), d))) {
      break;
    }
  }
  return dir_list.join('/');
};

dot_sat = '.sat';

dot_cubesat = '.cubesat';

site_path = findRoot(dot_sat);

dot_sat_path = add(site_path, dot_sat);

cubesat_path = findRoot(dot_cubesat);

dot_cubesat_path = add(cubesat_path || home, dot_cubesat);

node_modules = findRoot('node_modules') || home;

if (site_path === '' && __indexOf.call('help create npm-update npm-publish npm-install meteor-publish'.split(' '), command) < 0) {
  console.log('fatal: Not a .sat working directory or its subdirectories.');
  process.exit(1);
}

[home, cubesat_path, dot_cubesat_path, site_path].forEach(function(_path) {
  var dotenv_path;

  return fs.existsSync(dotenv_path = add(_path, '.env')) && dotenv.config({
    path: dotenv_path
  });
});

build_path = add(site_path, build_dir);

index_coffee_path = add(site_path, index_coffee);

env = function(v) {
  var _path;

  return (_path = process.env[v]) && _path.replace(/^~\//, home + '/');
};

test_path = fs.existsSync(test_path = add(cubesat_path, 'test')) ? test_path : void 0;

nocacheRequire = function(f) {
  return delete require.cache[f] && require(f);
};

loadSettings = function(f) {
  return (fs.existsSync(f) && x.func((nocacheRequire(f)).Settings)) || {};
};

Settings = loadSettings(settings_path = add(dot_cubesat_path, 'settings.coffee'));

(f = function(o) {
  return x.keys(o).forEach(function(k) {
    if (x.isObject(o[k])) {
      return o[k] = f(o[k]);
    } else {
      return o[k] = x.func(o[k]);
    }
  });
})(Settings);

settings_json = add(build_path, 'settings.json');

nconf.file({
  file: add(dot_sat_path, 'config.json')
});

this.Theme = this.Modules = {};

init_settings = function() {
  var local, site;

  Settings = loadSettings(settings_path);
  x.extend(Settings, loadSettings(index_coffee_path));
  (site = Settings.site) && (local = Settings.local) && local[site] && x.extend(Settings, local[site]);
  return this.Settings = Settings;
};

init_settings();

lib_dir = 'lib';

client_dir = 'client';

public_dir = 'public';

build_client_path = add(build_path, client_dir);

build_lib_path = add(build_path, lib_dir);

build_public_path = add(build_path, public_dir);

style_path = add(site_path, 'style');

cubesat_name = 'isaac:cubesat';

lib_files = x.toArray(Settings.lib_files);

my_packages = x.toArray(Settings.packages);

public_files = x.toArray(Settings.public_files);

if (test_path) {
  test_client_path = add(test_path, client_dir);
  test_lib_path = add(test_path, lib_dir);
  test_public_path = add(test_path, public_dir);
  test_packages_path = add(test_path, 'packages');
  cubesat_package_path = add(test_packages_path, cubesat_name);
  package_paths = my_packages.map(function(p) {
    return add(test_packages_path, p);
  });
}

coffee_paths = function() {
  return (fs.readdirSync(site_path)).filter(function(f) {
    return coffee_ext === path.extname(f);
  }).map(function(f) {
    return add(site_path, f);
  });
};

updated = 'updated time';

log = function() {
  return (arguments != null) && ([].slice.call(arguments)).forEach(function(str) {
    return fs.appendFile(home + '/.log.io/cake', str, function(err) {
      if (err) {
        return console.log(err);
      }
    });
  });
};

error = function(e) {
  return e && (console.error(e) || 1);
};

isType = function(file, type) {
  return path.extname(file) === '.' + type;
};

collectExt = function(dir, ext) {
  return (fs.existsSync(dir) || '') && ((fs.readdirSync(dir)).map(function(file) {
    if (isType(file, ext)) {
      return fs.readFileSync(add(dir, file));
    } else {
      return '';
    }
  })).join('\n');
};

cd = function(dir) {
  return process.chdir(dir);
};

func = function(f) {
  if ('function' === typeof f) {
    return f();
  } else {
    return true;
  }
};

rmdir = function(dir, f) {
  if (fs.existsSync(dir)) {
    fs.readdirSync(dir).forEach(function(file, index) {
      var curPath;

      if (fs.lstatSync(curPath = add(dir, file)).isDirectory()) {
        return rmdir(curPath);
      } else {
        return fs.unlinkSync(curPath);
      }
    });
    fs.rmdirSync(dir);
  }
  func(f);
  return dir;
};

mkdir = function(dir, f) {
  return dir && fs.readdir(dir, function(e, l) {
    return e && fs.mkdir(dir, function(e) {
      return e || (f && f());
    });
  });
};

compare_file = function(source, target) {
  return false;
};

cp = function(source, target) {
  return !compare_file(source, target) && fs.readFile(source, function(e, data) {
    return error(e) || fs.readFile(target, function(e, data_t) {
      return e || (data.length > 0 && data.toString() !== data_t.toString()) && fs.writeFile(target, data, function() {});
    });
  });
};

cpdir = function(source, target) {
  return fs.readdir(source, function(e, list) {
    return list.map(function(f) {
      var t_f, _path;

      if (f.match(/^\./)) {
        return '';
      } else if ((fs.lstatSync(_path = add(source, f))).isDirectory()) {
        return mkdir((t_f = add(target, f)), function() {
          return cpdir(_path, t_f);
        });
      } else {
        return cp(_path, add(target, f));
      }
    });
  });
};

clean_up = function() {
  rmdir(build_client_path);
  return rmdir(build_lib_path);
};

daemon = function() {
  return ps.lookup({
    command: 'node',
    psargs: 'ux'
  }, function(e, a) {
    var node_ps;

    node_ps = a.map(function(p) {
      var _ref1, _ref2, _ref3;

      return (_ref1 = (_ref2 = p["arguments"]) != null ? (_ref3 = _ref2[0]) != null ? _ref3.match(/\/(log\.io-[a-z]+)$/) : void 0 : void 0) != null ? _ref1[1] : void 0;
    });
    __indexOf.call(node_ps, 'log.io-server') >= 0 || spawn('log.io-server', [], {
      stdio: 'inherit'
    });
    return __indexOf.call(node_ps, 'log.io-harvester') >= 0 || setTimeout((function() {
      return spawn('log.io-harvester', [], {
        stdio: 'inherit'
      });
    }), 100);
  });
};

coffee_clean = function() {
  return ps.lookup({
    command: 'node',
    psargs: 'ux'
  }, function(e, a) {
    return a.map(function(p) {
      var _ref1;

      return '-wbc' === ((_ref1 = p["arguments"]) != null ? _ref1[3] : void 0) && process.kill(p.pid, 'SIGKILL');
    });
  });
};

coffee_watch = function(c, js) {
  return spawn('coffee', ['-o', js, '-wbc', c], {
    stdio: 'inherit'
  });
};

coffee_compile = function() {
  var coffee_dir, js_dir;

  mkdir(build_lib_path);
  coffee_dir = [site_path];
  js_dir = [build_lib_path];
  package_paths && package_paths.map(function(p) {
    coffee_dir.push(add(p, 'coffee'));
    return js_dir.push(add(p, 'js'));
  });
  return ps.lookup({
    command: 'node',
    psargs: 'ux'
  }, function(e, a) {
    return a.map(function(p, i) {
      var c, _ref1;

      if ('-wbc' === ((_ref1 = p["arguments"]) != null ? _ref1[3] : void 0) && ((c = p["arguments"][4]) != null)) {
        if ((i = coffee_dir.indexOf(c)) < 0) {
          process.kill(p.pid, 'SIGKILL');
        } else {
          [coffee_dir.splice(i, 1), js_dir.splice(i, 1)];
        }
      }
      return a.length - 1 === i && coffee_dir.map(function(c, j) {
        return coffee_watch(c, js_dir[j]);
      });
    });
  });
};

meteor = function(dir, port) {
  if (port == null) {
    port = '3000';
  }
  cd(dir);
  return spawn('meteor', ['--port', port, '--settings', settings_json], {
    stdio: 'inherit'
  });
};

stop_meteor = function(func) {
  return ps.lookup({
    psargs: 'ux'
  }, function(err, a) {
    return a.map(function(p, i) {
      ['3000', '3300'].map(function(port) {
        var _ref1, _ref2;

        if ('--port' === ((_ref1 = p["arguments"]) != null ? _ref1[1] : void 0) && port === ((_ref2 = p["arguments"]) != null ? _ref2[2] : void 0)) {
          return process.kill(p.pid, 'SIGKILL');
        }
      });
      return a.length - 1 === i && (func != null) && func();
    });
  });
};

meteor_update = function() {
  cd(site_meteor_path);
  return spawn('meteor', ['update'], {
    stdio: 'inherit'
  });
};

meteor_publish_command = function() {
  return spawn('meteor', ['publish'], {
    stdio: 'inherit'
  });
};

meteor_command = function(command, argument, path) {
  cd(path);
  console.log('meteor', command, argument);
  return spawn('meteor', [command, argument], {
    stdio: 'inherit'
  });
};

spawn_command = function(bin, command, args, path) {
  path && cd(path);
  console.log(bin, command, args.join(' '));
  return spawn(bin, [command].concat(args), {
    stdio: 'inherit'
  });
};

start_meteor = function() {
  return stop_meteor(function() {
    return meteor(test_path, '3300');
  });
};

hold_watch = function(sec) {
  return updated = process.hrtime()[0] + sec;
};

start_up = function() {
  coffee_alone();
  lib_paths.concat([index_coffee_path]).map(function(f) {
    return chokidar.watch(f).on('change', function() {
      return build();
    });
  });
  hold_watch(2);
  package_paths.map(function(p) {
    return chokidar.watch(p).on('change', function(f) {
      var dir_f;

      if (updated < process.hrtime()[0]) {
        nconf.set('updated_packages', ((nconf.get('updated_packages')) || []).concat([dir_f = path.dirname(f)]).filter(function(v, i, a) {
          return a.indexOf(v) === i;
        }));
        return console.log(new Date(), 'Changed', f);
      }
    });
  });
  return commands();
};

commands = function() {
  var rl;

  rl = require('readline').createInterface(process.stdin, process.stdout);
  rl.setPrompt('');
  return rl.on('line', function(line) {
    switch ((line = line.replace(/\s{2,}/g, ' ').trim().split(' '))[0]) {
      case '.':
        return console.log('hi');
      case 'build':
        return build();
      case 'time':
        return console.log(new Date());
      case 'publish':
        return publish();
      case 'update':
        return meteor_update();
      case 'settings':
        return settings();
      case 'coffee':
        switch (line[1]) {
          case 'alone':
            return coffee_alone();
          case 'clean':
            return coffee_clean();
        }
        break;
      case 'meteor':
        return start_meteor();
      case 'packages':
        console.log(nconf.get('updated_packages'));
        return nconf.save();
      case 'get':
        return console.log(nconf.get(line[1]));
      case 'set':
        return nconf.set(line[1], line[2]);
      case 'stop':
        return 'meteor' === line[1] && stop_meteor();
      case '':
        return '';
      default:
        return console.log('?');
    }
  }).on('close', function() {
    console.log('bye!');
    coffee_clean();
    nconf.save();
    rl.close();
    return process.exit(1);
  });
};

meteor_packages_removed = 'autopublish insecure'.split(' ');

meteor_packages = ("service-configuration accounts-password fortawesome:fontawesome http iron:router " + cubesat_name + " jquery mizzao:bootstrap-3 mizzao:jquery-ui mquandalle:jade stylus").split(' ');

mobile_packages = [];

_meteor_run_ios = function() {
  return meteor_command('run', 'ios', mobile_path);
};

_add_packages = function() {
  return (meteor_packages.concat(mobile_packages).reduce((function(f, p) {
    return function() {
      return (meteor_command('add', p, mobile_path)).on('exit', f);
    };
  }), meteor_run_ios))();
};

_remove_packages = function() {
  return (meteor_packages_removed.reduce((function(f, p) {
    return function() {
      return (meteor_command('remove', p, mobile_path)).on('exit', f);
    };
  }), add_packages))();
};

_prepare_mobile = function() {
  'client lib public resources'.split(' ').map(function(d) {});
  'mobile.html mobile.css mobile.js'.split(' ').map(function(f) {
    return fs.unlink(add(mobile_path, f), function(e) {
      return error(e);
    });
  });
  return (['install-sdk', 'add-platform'].reduce((function(f, c) {
    return function() {
      return (meteor_command(c, 'ios', mobile_path)).on('exit', f);
    };
  }), remove_packages))();
};

to_be_removed_update_mobile = function() {
  return rmdir(mobile_path, function() {
    return (meteor_command('create', mobile_path, work)).on('exit', prepare_mobile);
  });
};

settings = function() {
  init_settings();
  delete Settings.local;
  console.log(settings_json);
  return fs.writeFile(settings_json, JSON.stringify(Settings, '', 4) + '\n', function(e, data) {
    return console.log(new Date() + 'Settings');
  });
};

to_be_removed_publish = function() {
  var updated_packages, version;

  version = {};
  updated_packages = nconf.get('updated_packages');
  return my_packages.map(function(v, i) {
    var isLast, package_dir;

    package_dir = add(test_packages_path, v);
    package_js = add(package_dir, package_js);
    isLast = my_packages.length - 1 === i;
    return (true || isLast || -1 < updated_packages.indexOf(package_dir)) && fs.readFile(package_js, 'utf8', function(e, data) {
      data.match(/version:\s*['"]([0-9.]+)['"]\s*,/m);
      version[v] = ((RegExp.$1.split('.')).map(function(w, j) {
        if (j === 2) {
          return String(Number(w) + 1);
        } else {
          return w;
        }
      })).join('.');
      data = data.replace(/(version:\s*['"])[0-9.]+(['"])/m, "$1" + version[v] + "$2");
      if (!isLast) {
        hold_watch(1);
        return fs.writeFile(package_js, data, 'utf8', function(e) {
          return e && console.log(new Date, e);
        });
      } else {
        async.map(x.keys(version), function(p) {
          return data = data.replace(new RegExp("api\.use\\('" + p + ".+$", 'm'), "api.use('" + p + "@" + version[p] + "');");
        });
        hold_watch(1);
        return fs.writeFile(package_js, data, 'utf8', function(e) {
          nconf.set('updated_packages', []);
          nconf.save();
          return e || x.keys(version).concat([my_packages[my_packages.length - 1]]).filter(function(v, i, a) {
            return a.indexOf(v) === i;
          }).map(function(d) {
            console.log(new Date, 'Publishing', d);
            cd(add(test_packages_path, d));
            return meteor_publish_command();
          });
        });
      }
    });
  });
};

coffee = function(data) {
  return cs.compile('#!/usr/bin/env node\n' + data, {
    bare: true
  });
};

directives = {
  jade: {
    file: '1.jade',
    f: function(n, b) {
      b = x.indent(b, 1);
      return "template(name='" + n + "')\n" + b + "\n\n";
    }
  },
  jade$: {
    file: '2.html',
    f: function(n, b) {
      b = x.indent(b, 1);
      return jade.compile("template(name='" + n + "')\n" + b + "\n\n", null)();
    }
  },
  HTML: {
    file: '3.html',
    f: function(n, b) {
      b = x.indent(b, 1);
      return "<template name=\"" + n + "\">\n" + b + "\n</template>\n";
    }
  },
  head: {
    file: '0.jade',
    header: function() {
      return 'head\n';
    },
    f: function(n, b) {
      return x.indent(b, 1) + '\n';
    }
  },
  less: {
    file: '7.less',
    f: function(n, b) {
      return b + '\n';
    }
  },
  css: {
    file: '5.css',
    header: function() {
      return collectExt(style_path, 'css') + '\n';
    },
    f: function(n, b) {
      return b + '\n';
    }
  },
  styl: {
    file: '4.styl',
    f: function(n, b) {
      return b + '\n\n';
    }
  },
  styl$: {
    file: '6.css',
    f: function(n, b) {
      return stylus(b).render() + '\n';
    }
  }
};

write_build = function(file, data) {
  var fwrite;

  return data.length > 0 && fs.readFile(fwrite = add(build_client_path, file), 'utf8', function(err, d) {
    return ((d == null) || data !== d) && fs.writeFile(fwrite, data, function(e) {
      return console.log(new Date(), fwrite);
    });
  });
};

toObject = function(v) {
  var o, r;

  if (v == null) {
    return {};
  } else if (x.isFunction(v)) {
    if (x.isScalar(r = v.call(this))) {
      return r;
    } else {
      return toObject(r);
    }
  } else if (x.isArray(v)) {
    return v.reduce((function(o, w) {
      return x.extend(o, toObject(w));
    }), {});
  } else if (x.isObject(v)) {
    return x.keys(v).reduce((function(o, k) {
      o[k] = x.isScalar(r = v[k]) ? r : toObject(r);
      return o;
    }), {});
  } else if (x.isString(v)) {
    return ((o = {})[v] = '') || o;
  }
};

no_seperator = 'jade jade$'.split(' ');

toTidy = function(v, d) {
  if (x.isString(v[d])) {
    return v[d];
  } else {
    return x.tideValue(x.tideKey(toObject(v[d]), v.id, __indexOf.call(no_seperator, d) >= 0 ? '' : ' '));
  }
};

toString = function(v, d) {
  var data, str;

  if (x.isString(v[d])) {
    str = v[d];
  } else {
    v[d] = toObject(v[d]);
    str = x.indentStyle(toTidy(v, d));
  }
  if (x.isEmpty(data = toObject(v.eco))) {
    return str;
  } else {
    return eco.render(str, toObject(data));
  }
};

readExports = function(f, kind) {
  var base;

  return x.func(index_basename === (base = path.basename(f, coffee_ext)) ? (nocacheRequire(f))[kind] : (updateRequire(f))[base][kind]);
};

build = function() {
  console.log(new Date() + 'build');
  init_settings();
  mkdir(build_client_path);
  this.Modules = coffee_paths().reduce((function(o, f) {
    return x.extend(o, readExports(f, 'Modules'));
  }), {});
  x.keys(this.Modules).map(function(name) {
    return x.module(name, this.Modules[name]);
  });
  x.keys(directives).map(function(d) {
    var it;

    return write_build((it = directives[d]).file, (x.func(it.header) || '') + x.keys(this.Modules).map(function(n) {
      var b;

      return (b = toString(this.Modules[n], d)) && it.f.call(this, n, b);
    }).filter(function(o) {
      return o != null;
    }).join(''));
  });
  return x.keys(this.Modules).map(function(n, i) {
    return this.Modules[n].absurd && api.add(toTidy(this.Modules[n], 'absurd'));
  }).concat([write_build('absurd.css', api.compile())]);
};

gitpass = function() {
  prompt.message = 'github';
  prompt.start();
  return prompt.get({
    name: 'password',
    hidden: true
  }, function(err, result) {
    fs.writeFileSync(add(home, '/.netrc'), "machine github.com\n    login i4han\n    password " + result.password, {
      flag: 'w+'
    });
    return Config.quit(process.exit(1));
  });
};

github_file = function(file) {
  var req;

  req = https.request({
    host: 'raw.githubusercontent.com',
    port: 443,
    method: 'GET',
    path: add('/', argv.user || 'i4han', argv.repo || 'sat-init', argv.branch || 'master', path.basename(file))
  }, function(res) {
    res.setEncoding('utf8');
    return res.on('data', function(b) {
      return fs.writeFile(file, b, 'utf8', function(e) {
        return console.log('written:', file);
      });
    });
  });
  req.end();
  return req.on('error', function(e) {
    return console.log('problem with request: ' + e.message);
  });
};

github_url = function(id_slash_repo) {
  return 'https://github.com/' + (id_slash_repo || 'i4han/sat-init') + '.git';
};

create = function() {
  var site;

  site = argv._[0];
  site.length > 0 || console.error("Can not create", site);
  return fs.mkdir(site, function(e) {
    e && (console.log("Can not create", site, "\nAlready exists?") || process.exit(1));
    return (spawn_command('git', 'clone', [github_url(), '.'], site)).on('exit', function(code) {
      code && (console.log('Git exited with error.') || process.exit(1));
      mkdir(add((site_path = process.cwd()), sat_dir));
      return (meteor_command('create', build_dir, site_path)).on('exit', function() {
        build_path = add(site_path, build_dir);
        return (meteor_packages_removed.reduce((function(f, p) {
          return function() {
            return (meteor_command('remove', p, build_path)).on('exit', f);
          };
        }), function() {
          return (meteor_packages.concat(mobile_packages).reduce((function(f, p) {
            return function() {
              return (meteor_command('add', p, build_path)).on('exit', f);
            };
          }), function() {
            return '.html .css .js'.split(' ').map(function(f) {
              return fs.unlink(add(build_path, build_dir + f), function(e) {
                return error(e);
              });
            });
          }))();
        }))();
      });
    });
  });
};

incVersion = function(data, re) {
  var version;

  data.match(re);
  console.log('verion:', version = RegExp.$2.split('.').map(function(w, j) {
    if (j === 2) {
      return String(+w + 1);
    } else {
      return w;
    }
  }).join('.'));
  return data.replace(re, "$1" + version + "$3");
};

getVersion = function(file, re) {
  return fs.readFileSync(file, 'utf8').match(re)[2];
};

readWrite = function(file, func) {
  return fs.readFile(file, 'utf8', function(e, data) {
    return error(e) || fs.writeFile(file, func(data, 'utf8', function(err) {
      return error(err);
    }));
  });
};

publish = function(file, re) {
  if (!test_path) {
    console.log('TEST_PATH is null') || process.exit(0);
  }
  return readWrite(add(cubesat_package_path, file), function(data) {
    return incVersion(data, re);
  });
};

rePublish = {
  npm: /("version"\s*:\s*['"])([0-9.]+)(['"]\s*,)/m,
  meteor: /(version\s*:\s*['"])([0-9.]+)(['"]\s*,)/m
};

npm_publish = function() {
  publish(package_json, rePublish.npm);
  return spawn_command('npm', 'publish', ['.'], cubesat_package_path);
};

meteor_publish = function() {
  publish(package_js, rePublish.meteor);
  return spawn_command('meteor', 'publish', [], cubesat_package_path);
};

meteor_install = function() {
  return spawn_command('meteor', 'add', [cubesat_name + '@' + getVersion(add(cubesat_package_path, package_js), rePublish.meteor)], build_path);
};

npm_install = function() {
  return spawn_command('npm', 'install', ['--prefix', node_modules, 'cubesat'], process.cwd());
};

npm_update = function() {
  return npm_publish().on('exit', function(code) {
    return code || npm_install();
  });
};

meteor_update = function() {
  return meteor_publish().on('exit', function(code) {
    return code || meteor_install();
  });
};

run = function() {
  settings();
  coffee_compile();
  build();
  spawn_command('meteor', 'run', ['--settings', settings_json, '--port', '3000'], build_path);
  return argv['with-test'] && test();
};

test = function() {
  if (!test_path) {
    console.log('$TEST_PATH is null') || process.exit(0);
  }
  'client server lib public private'.split(' ').forEach(function(d) {
    var target;

    return fs.unlink(target = add(test_path, d), function() {
      var source;

      return fs.existsSync(source = add(build_path, d)) && fs.symlink(source, target, 'dir', function() {
        return console.log(new Date(), source);
      });
    });
  });
  return spawn_command('meteor', 'run', ['--settings', settings_json, '--port', '3300'], test_path);
};

version = function() {
  return console.log('version: 0.4.31');
};

help = function() {
  return x.keys(tasks).map(function(k) {
    return console.log('  ', (k + Array(15).join(' ')).slice(0, 16), tasks[k].description);
  });
};

init = function() {
  return '';
};

tasks = {
  test: {
    call: (function() {
      return test();
    }),
    description: 'Test environment.'
  },
  init: {
    call: (function() {
      return init();
    }),
    description: 'Init .cubesat.'
  },
  help: {
    call: (function() {
      return help();
    }),
    description: 'Help message.'
  },
  create: {
    call: (function() {
      return create();
    }),
    description: 'Create a project.'
  },
  run: {
    call: (function() {
      return run();
    }),
    description: 'Run meteor server.'
  },
  build: {
    call: (function() {
      return build();
    }),
    description: 'Build meteor client files.'
  },
  settings: {
    call: (function() {
      return settings();
    }),
    description: 'Settings'
  },
  version: {
    call: (function() {
      return version();
    }),
    description: 'Print version'
  },
  publish: {
    call: (function() {
      return publish();
    }),
    description: 'Publish Meteor packages.'
  },
  coffee: {
    call: (function() {
      return coffee_compile();
    }),
    description: 'Watching coffee files to complie.'
  },
  'npm-update': {
    call: (function() {
      return npm_update();
    }),
    description: 'Publish and install npm cubesat packages.'
  },
  'npm-install': {
    call: (function() {
      return npm_install();
    }),
    description: 'Install cubesat npm package'
  },
  'npm-publish': {
    call: (function() {
      return npm_publish();
    }),
    description: 'Publish cubesat to npm'
  },
  'meteor-update': {
    call: (function() {
      return meteor_update();
    }),
    description: 'Publish and install meteor cubesat packages.'
  },
  'meteor-install': {
    call: (function() {
      return meteor_install();
    }),
    description: 'Install meteor cubesat packages.'
  },
  'meteor-publish': {
    call: (function() {
      return meteor_publish();
    }),
    description: 'Publish cubesat to meteor'
  }
};

(task = tasks[command]) && task.call();

task || help();
