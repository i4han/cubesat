// Generated by CoffeeScript 1.8.0
var Settings, add, api, argv, async, build, build_client_path, build_dir, build_lib_path, build_path, build_public_path, cd, chokidar, client_dir, coffee, coffee_clean, coffee_compile, coffee_ext, coffee_paths, coffee_watch, collectExt, command, compare_file, cp, cpdir, create, create_test, cs, cubesat_name, cubesat_package_path, cubesat_path, cwd, directives, dot_cubesat, dot_cubesat_path, dot_sat, dot_sat_path, dotenv, eco, env, error, exec, f, findRoot, fs, func, getVersion, github_file, github_url, gitpass, help, home, https, incVersion, index_basename, index_coffee, index_coffee_path, init, init_settings, install_mobile, isType, jade, lib_dir, lib_files, loadSettings, log, meteor, meteor_create, meteor_install, meteor_packages, meteor_packages_removed, meteor_publish, meteor_update, mkdir, mobile_packages, my_packages, nconf, no_seperator, nocacheRequire, node_modules, npm_install, npm_publish, npm_update, ok, options, package_js, package_json, package_paths, packages_dir, path, ps, public_dir, public_files, rePublish, readExports, readWrite, rmdir, run, settings, settings_json, settings_path, site_path, spawn, spawn_command, style_path, stylus, task, tasks, test, test_client_path, test_dir, test_lib_path, test_packages_path, test_path, test_public_path, toObject, toString, toTidy, updated, version, with_test, write_build, x, __clean_up, __commands, __daemon, __hold_watch, __meteor_command, __meteor_publish_command, __meteor_update, __start_meteor, __start_up, __stop_meteor, _install_mobile, _meteor_run, _publish, _ref, _ref1,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

fs = require('fs');

path = require('path');

ps = require('ps-node');

cs = require('coffee-script');

eco = require('eco');

chokidar = require('chokidar');

https = require('https');

jade = require('jade');

stylus = require('stylus');

async = require('async');

dotenv = require('dotenv');

nconf = require('nconf');

api = require('absurd')();

_ref = require('child_process'), spawn = _ref.spawn, exec = _ref.exec;

x = require('cubesat').x;

cs.register();

command = process.argv[2];

argv = require('minimist')(process.argv.slice(3));

add = path.join;

home = process.env.HOME;

cwd = process.cwd();

build_dir = 'build';

index_basename = 'index';

coffee_ext = '.coffee';

index_coffee = index_basename + coffee_ext;

package_js = 'package.js';

package_json = 'package.json';

findRoot = function(d) {
  var dir_list;
  dir_list = process.cwd().split('/').concat([true]);
  while (dir_list.pop()) {
    if (fs.existsSync(add(dir_list.join('/'), d))) {
      break;
    }
  }
  return dir_list.join('/');
};

dot_sat = '.sat';

dot_cubesat = '.cubesat';

site_path = findRoot(dot_sat);

dot_sat_path = add(site_path, dot_sat);

cubesat_path = findRoot(dot_cubesat);

dot_cubesat_path = add(cubesat_path || home, dot_cubesat);

node_modules = findRoot('node_modules') || home;

tasks = {
  ok: {
    call: (function() {
      return ok();
    }),
    dotsat: 0,
    test: 0,
    description: ''
  },
  test: {
    call: (function() {
      return test();
    }),
    dotsat: 1,
    test: 0,
    description: 'Test environment.'
  },
  init: {
    call: (function() {
      return init();
    }),
    dotsat: 0,
    test: 0,
    description: 'Init .cubesat.'
  },
  help: {
    call: (function() {
      return help();
    }),
    dotsat: 0,
    test: 0,
    description: 'Help message.'
  },
  create: {
    call: (function() {
      return create();
    }),
    dotsat: 0,
    test: 0,
    description: 'Create a project.'
  },
  run: {
    call: (function() {
      return run();
    }),
    dotsat: 1,
    test: 0,
    description: 'Run meteor server.'
  },
  build: {
    call: (function() {
      return build();
    }),
    dotsat: 1,
    test: 0,
    description: 'Build meteor client files.'
  },
  settings: {
    call: (function() {
      return settings();
    }),
    dotsat: 1,
    test: 0,
    description: 'Settings'
  },
  version: {
    call: (function() {
      return version();
    }),
    dotsat: 0,
    test: 0,
    description: 'Print sat version'
  },
  publish: {
    call: (function() {
      return publish();
    }),
    dotsat: 0,
    test: 0,
    description: 'Publish Meteor packages.'
  },
  coffee: {
    call: (function() {
      return coffee_compile();
    }),
    dotsat: 1,
    test: 0,
    description: 'Watching coffee files to complie.'
  },
  'create-test': {
    call: (function() {
      return create_test();
    }),
    dotsat: 0,
    test: 1,
    description: 'Create test directory.'
  },
  'install-mobile': {
    call: (function() {
      return install_mobile();
    }),
    dotsat: 0,
    test: 1,
    description: 'Install mobile sdk and platform.'
  },
  'npm-update': {
    call: (function() {
      return npm_update();
    }),
    dotsat: 0,
    test: 1,
    description: 'Publish and install npm cubesat packages.'
  },
  'npm-install': {
    call: (function() {
      return npm_install();
    }),
    dotsat: 0,
    test: 0,
    description: 'Install cubesat npm package'
  },
  'npm-publish': {
    call: (function() {
      return npm_publish();
    }),
    dotsat: 0,
    test: 1,
    description: 'Publish cubesat to npm'
  },
  'meteor-update': {
    call: (function() {
      return meteor_update();
    }),
    dotsat: 1,
    test: 1,
    description: 'Publish and install meteor cubesat packages.'
  },
  'meteor-install': {
    call: (function() {
      return meteor_install();
    }),
    dotsat: 1,
    test: 0,
    description: 'Install meteor cubesat packages.'
  },
  'meteor-publish': {
    call: (function() {
      return meteor_publish();
    }),
    dotsat: 0,
    test: 1,
    description: 'Publish cubesat to meteor'
  }
};

options = {
  t: {
    full: 'with-test',
    command: ['run', 'coffee', 'install-mobile'],
    description: 'Excute with test.'
  }
};

if (site_path === '' && ((_ref1 = tasks[command]) != null ? _ref1.dotsat : void 0)) {
  console.log('fatal: "sat' + command + '" must run in .sat working directory or its subdirectory.');
  process.exit(1);
}

[home, cubesat_path, dot_cubesat_path, site_path].forEach(function(_path) {
  var dotenv_path;
  return fs.existsSync(dotenv_path = add(_path, '.env')) && dotenv.config({
    path: dotenv_path
  });
});

build_path = add(site_path, build_dir);

index_coffee_path = add(site_path, index_coffee);

env = function(v) {
  var _path;
  return (_path = process.env[v]) && _path.replace(/^~\//, home + '/');
};

test_dir = (function() {
  var _ref2;
  switch (false) {
    case !(with_test = argv['with-test'] && x.isString(with_test)):
      return with_test;
    case !(((_ref2 = tasks[command]) != null ? _ref2.test : void 0) && argv._[0]):
      return argv._[0];
    default:
      return 'test';
  }
})();

test_path = fs.existsSync(test_path = add(cubesat_path, test_dir)) ? test_path : void 0;

nocacheRequire = function(f) {
  return delete require.cache[f] && require(f);
};

loadSettings = function(f) {
  return (fs.existsSync(f) && x.func((nocacheRequire(f)).Settings)) || {};
};

Settings = loadSettings(settings_path = add(dot_cubesat_path, 'settings.coffee'));

(f = function(o) {
  return x.keys(o).forEach(function(k) {
    if (x.isObject(o[k])) {
      return o[k] = f(o[k]);
    } else {
      return o[k] = x.func(o[k]);
    }
  });
})(Settings);

settings_json = add(build_path, 'settings.json');

nconf.file({
  file: add(dot_sat_path, 'config.json')
});

this.Theme = this.Modules = {};

init_settings = function() {
  var local, site;
  Settings = loadSettings(settings_path);
  x.extend(Settings, loadSettings(index_coffee_path));
  (site = Settings.site) && (local = Settings.local) && local[site] && x.extend(Settings, local[site]);
  return this.Settings = Settings;
};

init_settings();

lib_dir = 'lib';

client_dir = 'client';

public_dir = 'public';

packages_dir = 'packages';

build_client_path = add(build_path, client_dir);

build_lib_path = add(build_path, lib_dir);

build_public_path = add(build_path, public_dir);

style_path = add(site_path, 'style');

cubesat_name = 'isaac:cubesat';

lib_files = x.toArray(Settings.lib_files);

my_packages = x.toArray(Settings.packages);

public_files = x.toArray(Settings.public_files);

if (test_path) {
  test_client_path = add(test_path, client_dir);
  test_lib_path = add(test_path, lib_dir);
  test_public_path = add(test_path, public_dir);
  test_packages_path = add(test_path, packages_dir);
  cubesat_package_path = add(test_packages_path, cubesat_name);
  package_paths = my_packages.map(function(p) {
    return add(test_packages_path, p);
  });
}

coffee_paths = function() {
  return (fs.readdirSync(site_path)).filter(function(f) {
    return coffee_ext === path.extname(f);
  }).map(function(f) {
    return add(site_path, f);
  });
};

updated = 'updated time';

log = function() {
  return (arguments != null) && ([].slice.call(arguments)).forEach(function(str) {
    return fs.appendFile(home + '/.log.io/cake', str, function(err) {
      if (err) {
        return console.log(err);
      }
    });
  });
};

error = function(e) {
  return e && (console.error(e) || 1);
};

isType = function(file, type) {
  return path.extname(file) === '.' + type;
};

collectExt = function(dir, ext) {
  return (fs.existsSync(dir) || '') && ((fs.readdirSync(dir)).map(function(file) {
    if (isType(file, ext)) {
      return fs.readFileSync(add(dir, file));
    } else {
      return '';
    }
  })).join('\n');
};

cd = function(dir) {
  return process.chdir(dir);
};

func = function(f) {
  if ('function' === typeof f) {
    return f();
  } else {
    return true;
  }
};

rmdir = function(dir, f) {
  if (fs.existsSync(dir)) {
    fs.readdirSync(dir).forEach(function(file, index) {
      var curPath;
      if (fs.lstatSync(curPath = add(dir, file)).isDirectory()) {
        return rmdir(curPath);
      } else {
        return fs.unlinkSync(curPath);
      }
    });
    fs.rmdirSync(dir);
  }
  func(f);
  return dir;
};

mkdir = function(dir, _path, f) {
  _path && process.chdir(_path);
  return dir && fs.readdir(dir, function(e, l) {
    return e && fs.mkdir(dir, function(e) {
      return e || x.isFunction(f) && f();
    });
  });
};

compare_file = function(source, target) {
  return false;
};

cp = function(source, target) {
  return !compare_file(source, target) && fs.readFile(source, function(e, data) {
    return error(e) || fs.readFile(target, function(e, data_t) {
      return e || (data.length > 0 && data.toString() !== data_t.toString()) && fs.writeFile(target, data, function() {});
    });
  });
};

cpdir = function(source, target) {
  return fs.readdir(source, function(e, list) {
    return list.map(function(f) {
      var t_f, _path;
      if (f.match(/^\./)) {
        return '';
      } else if ((fs.lstatSync(_path = add(source, f))).isDirectory()) {
        return mkdir((t_f = add(target, f)), null, function() {
          return cpdir(_path, t_f);
        });
      } else {
        return cp(_path, add(target, f));
      }
    });
  });
};

__clean_up = function() {
  rmdir(build_client_path);
  return rmdir(build_lib_path);
};

__daemon = function() {
  return ps.lookup({
    command: 'node',
    psargs: 'ux'
  }, function(e, a) {
    var node_ps;
    node_ps = a.map(function(p) {
      var _ref2, _ref3, _ref4;
      return (_ref2 = (_ref3 = p["arguments"]) != null ? (_ref4 = _ref3[0]) != null ? _ref4.match(/\/(log\.io-[a-z]+)$/) : void 0 : void 0) != null ? _ref2[1] : void 0;
    });
    __indexOf.call(node_ps, 'log.io-server') >= 0 || spawn('log.io-server', [], {
      stdio: 'inherit'
    });
    return __indexOf.call(node_ps, 'log.io-harvester') >= 0 || setTimeout((function() {
      return spawn('log.io-harvester', [], {
        stdio: 'inherit'
      });
    }), 100);
  });
};

coffee_clean = function() {
  return ps.lookup({
    command: 'node',
    psargs: 'ux'
  }, function(e, a) {
    return a.map(function(p) {
      var _ref2;
      return '-wbc' === ((_ref2 = p["arguments"]) != null ? _ref2[3] : void 0) && process.kill(p.pid, 'SIGKILL');
    });
  });
};

coffee_watch = function(c, js) {
  return spawn('coffee', ['-o', js, '-wbc', c], {
    stdio: 'inherit'
  });
};

coffee_compile = function() {
  var coffee_dir, js_dir;
  mkdir(build_lib_path);
  coffee_dir = [site_path];
  js_dir = [build_lib_path];
  package_paths && package_paths.map(function(p) {
    coffee_dir.push(add(p, 'coffee'));
    return js_dir.push(add(p, 'js'));
  });
  return ps.lookup({
    command: 'node',
    psargs: 'ux'
  }, function(e, a) {
    return a.map(function(p, i) {
      var c, _ref2;
      if ('-wbc' === ((_ref2 = p["arguments"]) != null ? _ref2[3] : void 0) && ((c = p["arguments"][4]) != null)) {
        if ((i = coffee_dir.indexOf(c)) < 0) {
          process.kill(p.pid, 'SIGKILL');
        } else {
          [coffee_dir.splice(i, 1), js_dir.splice(i, 1)];
        }
      }
      return a.length - 1 === i && coffee_dir.map(function(c, j) {
        return coffee_watch(c, js_dir[j]);
      });
    });
  });
};

meteor = function(dir, port) {
  if (port == null) {
    port = '3000';
  }
  cd(dir);
  return spawn('meteor', ['--port', port, '--settings', settings_json], {
    stdio: 'inherit'
  });
};

__stop_meteor = function(func) {
  return ps.lookup({
    psargs: 'ux'
  }, function(err, a) {
    return a.map(function(p, i) {
      ['3000', '3300'].map(function(port) {
        var _ref2, _ref3;
        if ('--port' === ((_ref2 = p["arguments"]) != null ? _ref2[1] : void 0) && port === ((_ref3 = p["arguments"]) != null ? _ref3[2] : void 0)) {
          return process.kill(p.pid, 'SIGKILL');
        }
      });
      return a.length - 1 === i && (func != null) && func();
    });
  });
};

__meteor_update = function() {
  cd(site_meteor_path);
  return spawn('meteor', ['update'], {
    stdio: 'inherit'
  });
};

__meteor_publish_command = function() {
  return spawn('meteor', ['publish'], {
    stdio: 'inherit'
  });
};

__meteor_command = function(command, argument, path) {
  cd(path);
  console.log('meteor', command, argument);
  return spawn('meteor', [command, argument], {
    stdio: 'inherit'
  });
};

spawn_command = function(bin, command, args, _path) {
  _path && cd(_path);
  console.log(bin, command, args.join(' '));
  return spawn(bin, [command].concat(args), {
    stdio: 'inherit'
  });
};

__start_meteor = function() {
  return stop_meteor(function() {
    return meteor(test_path, '3300');
  });
};

__hold_watch = function(sec) {
  return updated = process.hrtime()[0] + sec;
};

__start_up = function() {
  coffee_alone();
  lib_paths.concat([index_coffee_path]).map(function(f) {
    return chokidar.watch(f).on('change', function() {
      return build();
    });
  });
  hold_watch(2);
  package_paths.map(function(p) {
    return chokidar.watch(p).on('change', function(f) {
      var dir_f;
      if (updated < process.hrtime()[0]) {
        nconf.set('updated_packages', ((nconf.get('updated_packages')) || []).concat([dir_f = path.dirname(f)]).filter(function(v, i, a) {
          return a.indexOf(v) === i;
        }));
        return console.log(new Date(), 'Changed', f);
      }
    });
  });
  return commands();
};

__commands = function() {
  var rl;
  rl = require('readline').createInterface(process.stdin, process.stdout);
  rl.setPrompt('');
  return rl.on('line', function(line) {
    switch ((line = line.replace(/\s{2,}/g, ' ').trim().split(' '))[0]) {
      case '.':
        return console.log('hi');
      case 'build':
        return build();
      case 'time':
        return console.log(new Date());
      case 'publish':
        return publish();
      case 'update':
        return meteor_update();
      case 'settings':
        return settings();
      case 'coffee':
        switch (line[1]) {
          case 'alone':
            return coffee_alone();
          case 'clean':
            return coffee_clean();
        }
        break;
      case 'meteor':
        return start_meteor();
      case 'packages':
        console.log(nconf.get('updated_packages'));
        return nconf.save();
      case 'get':
        return console.log(nconf.get(line[1]));
      case 'set':
        return nconf.set(line[1], line[2]);
      case 'stop':
        return 'meteor' === line[1] && stop_meteor();
      case '':
        return '';
      default:
        return console.log('?');
    }
  }).on('close', function() {
    console.log('bye!');
    coffee_clean();
    nconf.save();
    rl.close();
    return process.exit(1);
  });
};

meteor_packages_removed = 'autopublish insecure'.split(' ');

meteor_packages = ("service-configuration accounts-password fortawesome:fontawesome http iron:router " + cubesat_name + " jquery mizzao:bootstrap-3 mizzao:jquery-ui mquandalle:jade stylus").split(' ');

mobile_packages = [];

settings = function() {
  init_settings();
  delete Settings.local;
  console.log(settings_json);
  return fs.writeFile(settings_json, JSON.stringify(Settings, '', 4) + '\n', function(e, data) {
    return console.log(new Date() + ' Settings are written.');
  });
};

coffee = function(data) {
  return cs.compile('#!/usr/bin/env node\n' + data, {
    bare: true
  });
};

directives = {
  jade: {
    file: '1.jade',
    f: function(n, b) {
      b = x.indent(b, 1);
      return "template(name='" + n + "')\n" + b + "\n\n";
    }
  },
  jade$: {
    file: '2.html',
    f: function(n, b) {
      b = x.indent(b, 1);
      return jade.compile("template(name='" + n + "')\n" + b + "\n\n", null)();
    }
  },
  HTML: {
    file: '3.html',
    f: function(n, b) {
      b = x.indent(b, 1);
      return "<template name=\"" + n + "\">\n" + b + "\n</template>\n";
    }
  },
  head: {
    file: '0.jade',
    header: function() {
      return 'head\n';
    },
    f: function(n, b) {
      return x.indent(b, 1) + '\n';
    }
  },
  less: {
    file: '7.less',
    f: function(n, b) {
      return b + '\n';
    }
  },
  css: {
    file: '5.css',
    header: function() {
      return collectExt(style_path, 'css') + '\n';
    },
    f: function(n, b) {
      return b + '\n';
    }
  },
  styl: {
    file: '4.styl',
    f: function(n, b) {
      return b + '\n\n';
    }
  },
  styl$: {
    file: '6.css',
    f: function(n, b) {
      return stylus(b).render() + '\n';
    }
  }
};

write_build = function(file, data) {
  var fwrite;
  return data.length > 0 && fs.readFile(fwrite = add(build_client_path, file), 'utf8', function(err, d) {
    return ((d == null) || data !== d) && fs.writeFile(fwrite, data, function(e) {
      return console.log(new Date(), fwrite);
    });
  });
};

toObject = function(v) {
  var o, r;
  if (v == null) {
    return {};
  } else if (x.isFunction(v)) {
    if (x.isScalar(r = v.call(this))) {
      return r;
    } else {
      return toObject(r);
    }
  } else if (x.isArray(v)) {
    return v.reduce((function(o, w) {
      return x.extend(o, toObject(w));
    }), {});
  } else if (x.isObject(v)) {
    return x.keys(v).reduce((function(o, k) {
      o[k] = x.isScalar(r = v[k]) ? r : toObject(r);
      return o;
    }), {});
  } else if (x.isString(v)) {
    return ((o = {})[v] = '') || o;
  }
};

no_seperator = 'jade jade$'.split(' ');

toTidy = function(v, d) {
  if (x.isString(v[d])) {
    return v[d];
  } else {
    return x.tideValue(x.tideKey(toObject(v[d]), v.id, __indexOf.call(no_seperator, d) >= 0 ? '' : ' '));
  }
};

toString = function(v, d) {
  var data, str;
  if (x.isString(v[d])) {
    str = v[d];
  } else {
    v[d] = toObject(v[d]);
    str = x.indentStyle(toTidy(v, d));
  }
  if (x.isEmpty(data = toObject(v.eco))) {
    return str;
  } else {
    return eco.render(str, toObject(data));
  }
};

readExports = function(f, kind) {
  var base;
  return x.func(index_basename === (base = path.basename(f, coffee_ext)) ? (nocacheRequire(f))[kind] : (updateRequire(f))[base][kind]);
};

build = function() {
  settings();
  spawn_command('coffee', '-bc', ['-o', build_lib_path, site_path]);
  init_settings();
  mkdir(build_client_path);
  this.Modules = coffee_paths().reduce((function(o, f) {
    return x.extend(o, readExports(f, 'Modules'));
  }), {});
  x.keys(this.Modules).map(function(n) {
    return x.module(n, this.Modules[n] = x.func(this.Modules[n], x.func(this.Modules[n])));
  });
  x.keys(directives).map(function(d) {
    var it;
    return write_build((it = directives[d]).file, (x.func(it.header) || '') + x.keys(this.Modules).map(function(n) {
      var b;
      return (b = toString(this.Modules[n], d)) && it.f.call(this, n, b);
    }).filter(function(o) {
      return o != null;
    }).join(''));
  });
  return x.keys(this.Modules).map(function(n, i) {
    return this.Modules[n].style && api.add(toTidy(this.Modules[n], 'style'));
  }).concat([write_build('absurd.css', api.compile())]);
};

gitpass = function() {
  prompt.message = 'github';
  prompt.start();
  return prompt.get({
    name: 'password',
    hidden: true
  }, function(err, result) {
    fs.writeFileSync(add(home, '/.netrc'), "machine github.com\n    login i4han\n    password " + result.password, {
      flag: 'w+'
    });
    return Config.quit(process.exit(1));
  });
};

github_file = function(file) {
  var req;
  req = https.request({
    host: 'raw.githubusercontent.com',
    port: 443,
    method: 'GET',
    path: add('/', argv.user || 'i4han', argv.repo || 'sat-init', argv.branch || 'master', path.basename(file))
  }, function(res) {
    res.setEncoding('utf8');
    return res.on('data', function(b) {
      return fs.writeFile(file, b, 'utf8', function(e) {
        return console.log('written:', file);
      });
    });
  });
  req.end();
  return req.on('error', function(e) {
    return console.log('problem with request: ' + e.message);
  });
};

github_url = function(repo) {
  return 'https://github.com/' + repo + '.git';
};

meteor_create = function(dir, fn) {
  return (spawn_command('meteor', 'create', [dir], site_path = process.cwd())).on('exit', function() {
    build_path = add(site_path, dir);
    return (meteor_packages_removed.reduce((function(f, p) {
      return function() {
        return (spawn_command('meteor', 'remove', [p], build_path)).on('exit', f);
      };
    }), function() {
      return (meteor_packages.concat(mobile_packages).reduce((function(f, p) {
        return function() {
          return (spawn_command('meteor', 'add', [p], build_path)).on('exit', f);
        };
      }), function() {
        '.html .css .js'.split(' ').map(function(f) {
          return fs.unlink(add(build_path, dir + f), function(e) {
            return error(e);
          });
        });
        return x.isFunction(fn) && fn();
      }))();
    }))();
  });
};

create = function() {
  var site;
  x.valid('name', site = argv._[0]) || console.error("error: Not a vaild name to create. Use alphanumeric and '.', '_', '-'.", site) || process.exit(1);
  return fs.mkdir(site, function(e) {
    e && (console.error("error: Can not create", site) || process.exit(1));
    return (spawn_command('git', 'clone', [github_url(argv.repo || 'i4han/sat-init'), '.'], site)).on('exit', function(code) {
      code && (console.error('error: Git exited with an error.') || process.exit(1));
      return fs.existsSync('./build/.meteor') || meteor_create(build_dir);
    });
  });
};

incVersion = function(data, re) {
  var version;
  data.match(re);
  console.log('verion:', version = RegExp.$2.split('.').map(function(w, j) {
    if (j === 2) {
      return String(+w + 1);
    } else {
      return w;
    }
  }).join('.'));
  return data.replace(re, "$1" + version + "$3");
};

getVersion = function(file, re) {
  return fs.readFileSync(file, 'utf8').match(re)[2];
};

readWrite = function(file, func) {
  return fs.readFile(file, 'utf8', function(e, data) {
    return error(e) || fs.writeFile(file, func(data, 'utf8', function(err) {
      return error(err);
    }));
  });
};

_publish = function(file, re) {
  if (!test_path) {
    console.log('TEST_PATH is null') || process.exit(0);
  }
  return readWrite(add(cubesat_package_path, file), function(data) {
    return incVersion(data, re);
  });
};

rePublish = {
  npm: /("version"\s*:\s*['"])([0-9.]+)(['"]\s*,)/m,
  meteor: /(version\s*:\s*['"])([0-9.]+)(['"]\s*,)/m
};

npm_publish = function() {
  _publish(package_json, rePublish.npm);
  return spawn_command('npm', 'publish', ['.'], cubesat_package_path);
};

meteor_publish = function() {
  _publish(package_js, rePublish.meteor);
  return spawn_command('meteor', 'publish', [], cubesat_package_path);
};

meteor_install = function() {
  return spawn_command('meteor', 'add', [cubesat_name + '@' + getVersion(add(cubesat_package_path, package_js), rePublish.meteor)], build_path);
};

npm_install = function() {
  return spawn_command('npm', 'install', ['--prefix', node_modules, 'cubesat'], process.cwd());
};

npm_update = function() {
  return npm_publish().on('exit', function(code) {
    return code || npm_install();
  });
};

meteor_update = function() {
  return meteor_publish().on('exit', function(code) {
    return code || meteor_install();
  });
};

_meteor_run = function(dir, port) {
  return spawn_command('meteor', 'run', argv._.concat(['--settings', settings_json, '--port', port || '3000']), dir || build_path);
};

coffee_watch = function(c, js) {
  return spawn('coffee', ['-o', js, '-wbc', c], {
    stdio: 'inherit'
  });
};

run = function() {
  build();
  _meteor_run();
  return argv['with-test'] && test();
};

test = function() {
  build();
  test_path || console.error('error: Can not find cubesat home.') || process.exit(1);
  'client server lib public private'.split(' ').forEach(function(d) {
    var target;
    return fs.unlink(target = add(test_path, d), function() {
      var source;
      return fs.existsSync(source = add(build_path, d)) && fs.symlink(source, target, 'dir', function() {
        return console.log(new Date(), source);
      });
    });
  });
  return _meteor_run(test_path, '3300');
};

create_test = function() {
  (test_path = argv._[0]) || console.error("error: Test directory name is missing.") || process.exit(1);
  if (fs.existsSync(test_path)) {
    return console.error("error: Directory already exist.");
  } else {
    return meteor_create(test_path, function() {
      return mkdir(packages_dir, null, function() {
        return mkdir(cubesat_name, packages_dir, function() {
          return (spawn_command('git', 'clone', [github_url('i4han/cubesat'), '.'], cubesat_name)).on('exit', function() {
            return console.info("info: cubesat package directory:", process.cwd());
          });
        });
      });
    });
  }
};

_install_mobile = function(dir, fn) {
  return (['install-sdk', 'add-platform'].reduce((function(f, c) {
    return function() {
      return (spawn_command('meteor', c, ['ios'], dir)).on('exit', f);
    };
  }), fn))();
};

install_mobile = function() {
  var wt;
  !site_path && !((wt = argv['with-test']) && test_path) && console.error("error: Run in .sat working directory or specify valid test name." || process.exit(1));
  return _install_mobile((wt ? test_path : build_path), function() {
    return console.log(new Date());
  });
};

version = function() {
  return console.log('version: ' + getVersion(add(node_modules, 'node_modules', 'cubesat', 'package.json'), rePublish.npm));
};

help = function() {
  return x.keys(tasks).map(function(k) {
    return console.log('  ', (k + Array(15).join(' ')).slice(0, 16), tasks[k].description);
  });
};

init = function() {
  return '';
};

ok = function() {
  return console.log(argv);
};

(task = tasks[command]) && task.call();

task || help();
